<?php
namespace JosephG\Roko\Domain\Security\Checks;

use JosephG\Roko\Domain\Security\KnownVulnerabilities\Entity\VulnerabilityCollection;
use JosephG\Roko\Domain\Security\KnownVulnerabilities\Entity\Vulnerability;
use JosephG\Roko\Domain\Security\Checks\ValueObject\Check;
use JosephG\Roko\Domain\Security\Checks\ValueObject\CheckStatus;
use JosephG\Roko\Domain\Security\Checks\ValueObject\Severity;

/**
 * Domain Service: Transforms VulnerabilityCollection into security checks.
 *
 * Emits business codes for recommendations - Application layer handles translation.
 */
final class VulnerabilityChecks {

	/** @var Check[] */
	private $checks;

	public function __construct( array $checks ) {
		$this->checks = $checks;
	}

	/**
	 * Create VulnerabilityChecks from VulnerabilityCollection domain entity.
	 *
	 * @param VulnerabilityCollection $vulnerabilityCollection Domain entity with known vulnerabilities.
	 */
	public static function fromVulnerabilityCollection( VulnerabilityCollection $vulnerabilityCollection ) {
		$vulnerabilities = $vulnerabilityCollection->getVulnerabilities();
		$checks          = array();

		// Overall vulnerability status check
		$overallCheck = self::createOverallVulnerabilityCheck( $vulnerabilityCollection );
		$checks[]     = $overallCheck;

		// Individual vulnerability checks (if any exist)
		foreach ( $vulnerabilities as $vulnerability ) {
			$individualCheck = self::createIndividualVulnerabilityCheck( $vulnerability );
			if ( $individualCheck ) {
				$checks[] = $individualCheck;
			}
		}

		return new self( $checks );
	}

	/**
	 * Create overall vulnerability status check.
	 */
	private static function createOverallVulnerabilityCheck( VulnerabilityCollection $collection ) {
		$hasVulnerabilities = $collection->hasVulnerabilities();
		$count              = $collection->getCount();

		$businessCode = $hasVulnerabilities ? 'vulnerabilities_found' : 'vulnerabilities_clean';
		$status       = $hasVulnerabilities ? CheckStatus::fail() : CheckStatus::pass();
		$severity     = self::calculateOverallSeverity( $collection );

		$label = $hasVulnerabilities
			? sprintf( 'Known Vulnerabilities (%d found)', $count )
			: 'Known Vulnerabilities';

		$description = $hasVulnerabilities
			? sprintf( '%d known vulnerabilities detected in your plugins and themes.', $count )
			: 'No known vulnerabilities detected in your plugins and themes.';

		return new Check(
			'vulnerability_overview',
			$label,
			$status,
			$severity,
			$description,
			array(
				'has_vulnerabilities' => $hasVulnerabilities,
				'count'               => $count,
				'severity_breakdown'  => self::getSeverityBreakdown( $collection ),
			),
			$businessCode,
			'roko'
		);
	}

	/**
	 * Create individual vulnerability check.
	 */
	private static function createIndividualVulnerabilityCheck( Vulnerability $vulnerability ) {
		$pluginSlug = $vulnerability->pluginSlug;
		$cveId      = $vulnerability->cve->id;
		$severity   = $vulnerability->severity;

		// Skip unknown/placeholder vulnerabilities
		if ( $pluginSlug === 'unknown' || $cveId === '0000-0000' ) {
			return null;
		}

		$businessCode  = 'vulnerability_' . strtolower( $severity );
		$checkSeverity = self::mapVulnerabilitySeverity( $severity );

		$label       = sprintf( '%s - %s', $pluginSlug, $cveId );
		$description = sprintf(
			'%s vulnerability in %s plugin. CVE: %s',
			ucfirst( $severity ),
			$pluginSlug,
			$cveId
		);

		return new Check(
			'vulnerability_' . md5( $pluginSlug . $cveId ), // Unique ID
			$label,
			CheckStatus::fail(), // All vulnerabilities are failures
			$checkSeverity,
			$description,
			array(
				'plugin_slug'  => $pluginSlug,
				'cve_id'       => $cveId,
				'severity'     => $severity,
				'published_at' => $vulnerability->publishedAt->format( \DateTimeInterface::ATOM ),
			),
			$businessCode,
			'roko'
		);
	}

	/**
	 * Calculate overall severity based on highest individual severity.
	 */
	private static function calculateOverallSeverity( VulnerabilityCollection $collection ) {
		if ( ! $collection->hasVulnerabilities() ) {
			return Severity::low(); // No vulnerabilities = low severity
		}

		$maxSeverity = 'low';
		foreach ( $collection->getVulnerabilities() as $vulnerability ) {
			$severity = strtolower( $vulnerability->severity );

			if ( $severity === 'critical' || $severity === 'high' ) {
				$maxSeverity = 'high';
				break; // Can't get higher than this
			} elseif ( $severity === 'medium' && $maxSeverity !== 'high' ) {
				$maxSeverity = 'medium';
			}
		}

		return self::mapVulnerabilitySeverity( $maxSeverity );
	}

	/**
	 * Map vulnerability severity string to Severity value object.
	 */
	private static function mapVulnerabilitySeverity( $severity ) {
		$severity = strtolower( $severity );

		switch ( $severity ) {
			case 'critical':
			case 'high':
				return Severity::high();
			case 'medium':
				return Severity::medium();
			case 'low':
			default:
				return Severity::low();
		}
	}

	/**
	 * Get severity breakdown statistics.
	 */
	private static function getSeverityBreakdown( VulnerabilityCollection $collection ) {
		$breakdown = array(
			'critical' => 0,
			'high'     => 0,
			'medium'   => 0,
			'low'      => 0,
		);

		foreach ( $collection->getVulnerabilities() as $vulnerability ) {
			$severity = strtolower( $vulnerability->severity );
			if ( isset( $breakdown[ $severity ] ) ) {
				++$breakdown[ $severity ];
			}
		}

		return $breakdown;
	}

	/**
	 * Convert checks to array format.
	 */
	public function toArray() {
		return array_map(
			function ( Check $check ) {
				return $check->toArray();
			},
			$this->checks
		);
	}

	/**
	 * Get all Check objects.
	 *
	 * @return Check[]
	 */
	public function getChecks(): array {
		return $this->checks;
	}
}
